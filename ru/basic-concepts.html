<span>
         <h3> <a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>
   Общее преставление
         </h3>

<p>
   Lisp - не тарабарщина, Lisp - это божественный, безумно древний язык! И невероятно простой. Научить лиспу можно даже дошкольника, лишь бы он умел читать и писать. Но вместе с этим из очень простых конструкций этого языка можно легко и быстро построить сложные, непостижимо умные программы.
   
<p>
   Вот список основных конструкций языка:

   <h4>Списки</h4>
<p>
   Списки являются самой базовой конструкцией Lisp. Не даром его название расшифровывается как "обработчик списков" (LISt Processor). Все, с чем работает Lisp, все является списками. И сама программа, которую дают выполнить Lisp'у - тоже список.</p>

<p>
   Конструируются списки с помощью круглых скобок - открывающей список скобки "(" и закрывающей его ")". А так как списков в программе много, то и скобок тоже много. Их количество у некоторых может вызывать даже некоторое возмущение, которые выражается в старом добром прочтении акронима Lisp как "Lots of Irritating, Stupid Parentheses" (много раздражающих, глупых скобок). Но к скобкам быстро привыкается, они легко занимают свое место и при правильном форматировании исходного текста программы нисколько не мешают. Что, впрочем, относится к любому языку программирования.</p>
   
<p>
   Между скобками размещаются элементы списка, разделенные пробелами, слева направо. Никаких ограничений на элементы не накладывается, это могут числа, строки, даже другие списки. Вкладывая списки в списки, мы формируем целое дерево элементов (если расположить списки соответственно уровню их вложенности и местом, где они должны были размещены). Это дерево в Lisp называется AST (АСД) - Abstract Syntax Tree (абстрактное синтаксическое дерево).</p>

<p>
   Вот несколько примеров списков
      <pre><code id="list1" data-language="scheme">(* 1 2 3 4 5 6 7 8 9)</code><button class="doit" onclick="doit(list.textContent)">отправить в терминал.</button></pre>
      <pre><code id="list1" data-language="scheme">(print "Hello, John!")</code><button class="doit" onclick="doit(list.textContent)">отправить в терминал.</button></pre>
      <pre><code id="list1" data-language="scheme">(print "Ну или привет, если так понятнее.")</code><button class="doit" onclick="doit(list.textContent)">отправить в терминал.</button></pre>
      <pre><code id="list1" data-language="scheme">(print "2+2 = " (+ 2 2))</code><button class="doit" onclick="doit(list.textContent)">отправить в терминал.</button></pre></p>

<p>
   Если список отдать на интерпретацию Lisp'у, он будет его понимать строго опеределенным образом - первый элемент списка Lisp будет считать операцией, командой, которую надо выполнить над оставшейся частью списка. Эта логика будет применена Lisp'ом к каждому элементу, если он в свою очередь является тоже списком; и так далее рекурсивно (разбор понятия <i>рекурсии</i> тоже оставим надлежащему времени и месту), пока не останется необработанных списков. Этот процесс и называется процессом интерпретации Lisp-программы (в терминах Lisp - EVAL).</p>
   
<p>   
   Существует довольно небольшой список (снова список, и это не игра слов) базовых команд, и довольно большой список построенных из них команд посложнее, которые собраны в стандарты (для Scheme - это, например, <a href="http://www.schemers.org/Documents/Standards/R5RS/">R5RS</a> Scheme, есть и многие другие; Ol реализует большую часть этого стандарта и может выполнять многие программы написанные для других диалектов Lisp следующих стандарту r5rs). Но об этом чуть позже, только упомяну, что <b>print</b> выводит элементы списка на стандартное устройство вывода (в консоль), <b>car</b> возвращает первый элемент списка, <b>cdr</b> возвращает оставшуюся часть списка (без первого элемента), а <b>*</b> - произведение элементов оставшейся части списка.</p>

<p>
   Что еще можно делать со списками мы рассмотрим позже.

   <h4>Числа</h4>
<p>   
   В Lisp числа подразделяются на несколько классов:
   <ol>
      <li>Класс integer чисел - это целые (Z) числа, их размер ограничен только размером оперативной памяти компьютера.
      В отличие от большинства языков программирования, они могут легко превышать размер регистра процессора, на котором выполняется программа.</li>
      <pre><code id="Z1" data-language="scheme">123456789876543212345678987654321</code><button class="doit" onclick="doit(Z1.textContent)">отправить в терминал.</button></pre>
      <pre><code id="Z2" data-language="scheme">(* 12345678987654321 98765432123456789)</code><button class="doit" onclick="doit(Z2.textContent)">отправить в терминал.</button></pre>
      
      <li>Класс rational чисел - это рациональные (Q) числа, которые представлены в виде дроби. В числителе дроби всегда содержится целое число, в знаменателе - натуральное (целое, большее нуля). В Ol числитель можно извлечь с помощью конструкции car, знаменатель - cdr.</li>
      <pre><code id="Q1" data-language="scheme">(print "todo: добавить пример")</code><button class="doit" onclick="doit(Q1.textContent)">отправить в терминал.</button></pre>
      
      <li>Класс complex чисел - это комплексные (C) числа, которые представлены в виде A+Bi, где A и B - целые или натуральные числа. Пробелы между частями комплексного числа не допускаются, иначе они будут проинтерпретированы как самостоятельные, раздельные элементы списка. В Ol действительную часть числа можно извлечь с помощью конструкции car, мнимую - cdr. В свою очередь, если это натуральные числа, к ним можно снова применить car и cdr.</li>
      <pre><code id="C1" data-language="scheme">(print "todo: добавить пример")</code><button class="doit" onclick="doit(C1.textContent)">отправить в терминал.</button></pre>

      <li>Иррациональные числа в Ol не поддерживаются. Но работу с ними можно организовать с помощью механизма расширений, о котором разговор будет в соответствующем разделе.</li>
   </ol></p>
   
   <h4>Строки</h4>
<p>   
   TBD.</p>

   <h4>Порты</h4>
<p>   
   TBD.</p>

   <h4>Символы</h4>
<p>   
   TBD.</p>

   <h4>Функции</h4>
<p>   
   TBD. (а также внешние функции, результат (dload))</p>

   <h4>Макросы</h4>
<p>   
   TBD.</p>

   Some works more.
</span>
