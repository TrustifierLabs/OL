---
layout: page
title:  "Общее преставление"
date:   2015-11-27 19:24:46
categories: ru
---

   Lisp - не тарабарщина, Lisp - это божественный, безумно древний язык! И невероятно простой. Научить лиспу можно даже дошкольника, лишь бы он умел читать и писать. Но вместе с этим из очень простых конструкций этого языка можно легко и быстро построить сложные, непостижимо умные программы.
   
   Вот список основных конструкций языка:

#### Списки

   Списки являются самой базовой конструкцией Lisp. Не даром его название расшифровывается как "обработчик списков" (LISt Processor). Все, с чем работает Lisp, является списками. И сама программа, которую дают выполнить Lisp'у - тоже список.

   Конструируются списки с помощью круглых скобок - открывающей список скобки "(" и закрывающей его ")". А так как списков в программе много, то и скобок тоже много. Их количество у некоторых может вызывать даже некоторое возмущение, которые выражается в старом добром прочтении акронима Lisp как "Lots of Irritating, Stupid Parentheses" (много раздражающих, глупых скобок). Но к скобкам быстро привыкается, они легко занимают свое место и при правильном форматировании исходного текста программы нисколько не мешают. Что, впрочем, относится к любому языку программирования.
   
   Между скобками размещаются элементы списка, разделенные пробелами, слева направо. Никаких ограничений на элементы не накладывается, это могут быть числа, строки, даже другие списки. Вкладывая списки в списки, мы формируем целое дерево элементов (если расположить списки соответственно уровню их вложенности и местом, где они должны были быть размещены). Это дерево в Lisp называется AST (АСД) - Abstract Syntax Tree (абстрактное синтаксическое дерево).

   Вот несколько примеров списков

<pre><code id="list1" data-language="scheme">(* 1 2 3 4 5 6 7 8 9)</code><button class="doit" onclick="doit(list1.textContent)">отправить в терминал</button></pre>

<pre><code id="list2" data-language="scheme">(print "Hello, John!")</code><button class="doit" onclick="doit(list2.textContent)">отправить в терминал</button></pre>

<pre><code id="list3" data-language="scheme">(print "Ну или привет, если так понятнее.")</code><button class="doit" onclick="doit(list3.textContent)">отправить в терминал</button></pre>

<pre><code id="list4" data-language="scheme">(print "2+2 = " (+ 2 2))</code><button class="doit" onclick="doit(list4.textContent)">отправить в терминал</button></pre>

   Если список отдать на интерпретацию Lisp'у, он будет его понимать строго опеределенным образом - первый элемент списка Lisp будет считать операцией, командой, которую надо выполнить над оставшейся частью списка. Эта логика будет применена Lisp'ом к каждому элементу, если он в свою очередь является тоже списком; и так далее рекурсивно (разбор понятия <i>рекурсии</i> тоже оставим надлежащему времени и месту), пока не останется необработанных списков. Этот процесс и называется процессом интерпретации Lisp-программы (в терминах Lisp - EVAL).
   
   Существует довольно небольшой список (снова список, и это не игра слов) базовых команд, и довольно большой список построенных из них команд посложнее, которые собраны в стандарты (для Scheme - это, например, [R5RS](http://www.schemers.org/Documents/Standards/R5RS/){:target="_blank"} Scheme, есть и многие другие; Ol реализует большую часть этого стандарта и может выполнять многие программы написанные для других диалектов Lisp следующих стандарту r5rs). Но об этом чуть позже, только упомяну, что **print** выводит элементы списка на стандартное устройство вывода (в консоль), **car** возвращает первый элемент списка, **cdr** возвращает оставшуюся часть списка (без первого элемента), а **\*** - произведение элементов оставшейся части списка.

   Что еще можно делать со списками мы рассмотрим позже.

#### Числа

   В Lisp числа подразделяются на несколько классов:

1. Класс integer чисел - это целые (Z) числа, их размер ограничен только размером оперативной памяти компьютера.
   В отличие от большинства языков программирования, они могут легко превышать размер регистра процессора, на котором выполняется программа.

   <pre><code id="Z1" data-language="scheme">123456789876543212345678987654321</code><button class="doit" onclick="doit(Z1.textContent)">отправить в терминал</button></pre>

   <pre><code id="Z2" data-language="scheme">(* 12345678987654321 98765432123456789)</code><button class="doit" onclick="doit(Z2.textContent)">отправить в терминал</button></pre>
      
2. Класс rational чисел - это рациональные (Q) числа, которые представлены в виде дроби. В числителе дроби всегда содержится целое число, в знаменателе - натуральное (целое, большее нуля). Дробь рационального числа всегда является несократимой, если попытаться ввести сократимую дробь, то интерпретатор Lisp автоматически ее сократит; если возможно, то даже до целого числа. В Ol числитель можно извлечь с помощью конструкции car, знаменатель - cdr.

   <pre><code id="Q1" data-language="scheme">(print "todo: добавить пример")</code><button class="doit" onclick="doit(Q1.textContent)">отправить в терминал</button></pre>
      
3. Класс complex чисел - это комплексные (C) числа, которые представлены в виде A+Bi, где A и B - целые или натуральные числа. Пробелы между частями комплексного числа не допускаются, иначе они будут проинтерпретированы как самостоятельные, раздельные элементы списка. В Ol действительную часть числа можно извлечь с помощью конструкции car, мнимую - cdr. В свою очередь, если это натуральные числа, к ним можно снова применить car и cdr.

   <pre><code id="C1" data-language="scheme">(print "todo: добавить пример")</code><button class="doit" onclick="doit(C1.textContent)">отправить в терминал</button></pre>

4. Иррациональные числа в Ol не поддерживаются. Но работу с ними можно организовать с помощью механизма расширений, о котором разговор будет в соответствующем разделе.
   
#### Строки

   TBD.

#### Порты

   TBD.

#### Символы

   TBD.

#### Функции

   TBD. (а также внешние функции, результат (dload))

#### Макросы

   TBD.

   Some works more.

