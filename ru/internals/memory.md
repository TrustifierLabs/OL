---
layout: page
title:  Организация памяти виртуальной машины Ol
date: 2016-05-05 12:03:10 UTC
categories: en
---


   Виртуальная машина Otus Lisp (olvm) является регистровой (R) виртуальной машиной, использующей для долговременного хранения данных динамическую кучу (Heap) под управлением сборщика мусора (Garbage collector, GC).

   Все данные, которыми оперирует olvm, как и в большинстве других языков программирования с динамической типизацией, делятся на две большие горуппы - значения value типа и значения reference типа.

   Значения value типа представляют собой непосредственные значения,  такие как константы (#true, #false) и небольшие числа (0, 1, 101); reference типа - указатели на объекты, размещаемые в памяти (списки, строки, кортежи). Объекты никогда не передаются по значению, только по ссылке. Value значения никогда не передаются по ссылке, только по значению. Чтобы сохранить value зеачние в памяти, его надо разместить в каком-либо reference объекте, например точечной паре.

### Регистры

   Регистров у olvm в насчитывается 128. Это число зависит от реализации и может быть задано в lang/register.scm как (define n-registers 128) и src/olvm.c как #define NR 128. Значения регистров программисту непосредственно недоступны.

   В регистрах хранятся либо ссылки на размещенные в куче объекты (references), либо непосредственные значения value типа.

   В процессе сборки мусора (gc, о ней чуть позже) именно значения регистров являются тем корнем, от которого начинает работать сборщик мусора. Все объекты, не доступные ни из одного регистра и из текущего контекста считаются мусором и отбрасываются в процессе сборки. Такой подход позволяет эффективно справляться с циклическимиз зависимостями уже ненужных объектов.
   
   Еще более детально - значения регистров складываются в куче в новый кортеж, который назначается корнем сборки. После сборки регистры восстанавливаются из кортежа, а кортеж уничтожается.
Вот пример кода, который это делает:
<pre><code>
   int p = 0, N = NR;
   word *regs = (word*) new_tuple (N + 1);
   while (++p <= N) regs[p] = R[p-1];
   regs[p] = (word) this; // текущий контекст

   heap.fp = fp;
   regs = (word*) gc(&heap, size, (word)regs);
   fp = heap.fp;

   this = (word *) regs[p];
   while (--p >= 1) R[p-1] = regs[p];
   fp = regs; // удалим созданный выше tuple
</code></pre>

### Куча

   Используемая olvm память, или "куча" (Heap), представляет собой динамически изменяемый линейный массив объектов, управляемый сборщиком мусора (Garbage Collector, GC). Ничего кроме объектов в куче разместить нельзя. Необходимо помнить, что в куче всегда резервируется место для внутреннего использования виртуальной машиной размером в количество регистров плюс два слов плюс один килобайт. 
   
   Размер кучи меняется только в процессе полной сборки мусора (о сборке будет дальше). Стратегия изменения размера кучи довольно проста: если свободное место в куче закончилось (меньше запрошенного у GC места, то куча увеличивается на 1/10 использованного размера плюс 4 килобайта; если же свободного места больше чем 20%, то куча уменьшается до 10% свободного места.

   Объект состоит из двух частей, заголовка (header) и наполнения (payload). Вот формат заголовка:
<pre><code>
   [... ssssssss ????rppp tttttt10]  ; два младших бита заголовока всегда(!) равны 10
    '----------| '--||'-| '----|
               |    ||  |      '-----> тип объекта, 6 бит
               |    ||  '------------> количество байт заполнения (padding), после конца raw-объектов, 3 бита
               |    |'---------------> бит "сырости" объекта (rawness), такие объекты содержат только линейный массив байт
               |    '----------------> зарезервированные биты, 4 бита
               '---------------------> размер объекта в машинных словах (размер слова минус 8 бит)
</code></pre>

   Наполнение объекта зависит от бита rawness. Если этот бит установлен, то объект содержит линейный массив битовых данных. Размер такого массива равен размеру объекта умноженному на количество байт в слове минус количество байт заполнения.
   
   Если же этот бит сброшен, то объект содержит линейный массив состоящий из либо value значений, либо обычных ссылок на память (на заголовки других объектов), либо и тех и тех вперемешку.
   
### Сборка мусора

   TBD.