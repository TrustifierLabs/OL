---
layout: page
title:  Организация памяти виртуальной машины Ol
date: 2016-03-14 18:10:12 UTC
categories: en
---

   Виртуальная машина Ol (olvm) является регистровой (R) виртуальной машиной, использующей для долговременного хранения данных динамическую кучу (Heap) под управлением сборщика мусора (Garbage collector, GC).

   Все данные, которыми оперирует виртуальная машина Ol (olvm), как и в большинстве других языков программирования с динамической типизацией, делятся на два типа - value тип и reference тип.

   Значения value типа представляют собой непосредственные значения, reference типа - указатели на объекты, размещаемые в памяти. Объекты никогда не передаются по значению, только по ссылке. Value значения никогда не передаются по ссылке, только по значению.

### Регистры

   Регистров у виртуальной машины в насчитывается 128. Это число зависит от реализации olvm и задается в lang/register.scm как (define n-registers 128) и src/olvm.c как #define NR 128. Значения регистров программисту непосредственно недоступны.

   В регистрах хранятся либо ссылки на размещенные в куче объекты, либо непосредственные значения - такие как небольшие числа (укладывающиеся в количество бит машинного слова минус 8), константы #true, #false, #null, #empty и другие.

   В процессе сборки мусора (gc, о ней чуть позже) именно значения регистров являются тем корнем, от которого начинает работать сборщик мусора. Значения регистров складываются в куче в отдельный кортеж (tuple), который назначается корнем сборки. После сборки регистры восстанавливаются из кортежа и кортеж уничтожается.
Пример кода, который это делает:
<pre><code>
    int p = 0, N = NR;
    word *regs = (word*) new_tuple (N + 1);
    while (++p <= N) regs[p] = R[p-1];
    regs[p] = (word) this;

    heap.fp = fp;
    regs = (word*) gc(&heap, size, (word)regs);
    fp = heap.fp;

    this = (word *) regs[p];
    while (--p >= 1) R[p-1] = regs[p];
    fp = regs; // удалим созданный выше tuple
</code></pre>

### Куча

   Память ol, или "куча" (Heap), представляет собой динамически изменяемый линейный массив объектов, управляюемый сборщиком мусора (Garbage Collector, GC). Ничего кроме объектов в куче разместить нельзя.

   Объект состоит из двух частей, заголовка (header) и наполнения (payload). Вот формат заголовка:
<pre><code>
   [... ssssssss ????rppp tttttt10]  ; два младших бита заголовока всегда(!) равны 10
    '----------| '--||'-| '----|
               |    ||  |      '-----> тип объекта, 6 бит
               |    ||  '------------> количество байт заполнения (padding), после конца raw-объектов, 3 бита
               |    |'---------------> бит "сырости" объекта (rawness), такие объекты содержат только линейный массив байт
               |    '----------------> зарезервированные биты, 4 бита
               '---------------------> размер объекта в машинных словах (размер слова минус 8 бит)
</code></pre>

   Наполнение объекта зависит от бита rawness. Если этот бит установлен, то объект содержит линейный массив битовых данных. Размер такого массива равен размеру объекта умноженному на количество байт в слове минус количество байт заполнения.
   
   Если же этот бит сброшен, то объект содержит линейный массив состоящий из либо value значений, либо обычных ссылок на память (на заголовки других объектов), либо и тех и тех вперемешку.
   
   